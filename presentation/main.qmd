.include {setup.qmd}
.include {title.qmd}

# Background

Analisi dei più noti strumenti ***"what you see is what you mean"*** .text content:{(wysiwym)} variant:{smallcaps}:

- **LaTeX**: pieno controllo, ripida curva di apprendimento

- **AsciiDoc**: poco controllo, semplice e leggibile, sintassi proprietaria

- **Typst**: pieno controllo, leggibile, sintassi proprietaria

- **MDX**: nessun controllo, destinato all'embedding

# Analisi

Nasce la necessità di realizzare uno strumento che al tempo stesso:
- adotti una sintassi standard di fatto, **semplice e leggibile**  
- permetta il **pieno controllo** del documento
- sia abbastanza versatile da supportare l'**esportazione in più formati**

.fragment
    &nbsp;  
    La scelta della sintassi ricade su **Markdown**, estremamente popolare nel mondo dell'open source.

    Markdown definisce tuttavia la formattazione del testo, ma non del layout.  
    **Come si centra del contenuto in Markdown?** .text content:{Non è possibile} size:{small}

# Quarkdown flavor

Per sopperire alle lacune di Markdown, nasce l'idea di una sua estensione che introduca le **chiamate a funzione**.

```
.align {center}
    Questo testo si trova al **centro**.
```

&nbsp;

Sono messe a disposizione funzioni di layout, di I/O, matematiche e anche di scripting.

Quarkdown è dunque **Turing complete**.

<<<

.row alignment:{spacearound}
    .column cross:{start} gap:{5mm}
        # Pipeline

        L'architettura del software segue una pipeline sequenziale.

        1. Registrazione delle librerie
        2. Lexing
        3. Parsing
        4. Espansione delle chiamate a funzione
        5. Attraversamento dell'albero
        6. Rendering
        7. Post-rendering

    !(_x530)[Pipeline](img/uml/pipeline.svg)

# Lexing

Vengono estratti i token dal codice sorgente tramite espressioni regolari.

>.row alignment:{center} cross:{start} gap:{2.5cm}
>    .column
>        #### Blocchi
>    
>        ~~~markdown
>        Hello, world!
>        > M'illumino d'immenso
>
>        ```java
>        public class Point {...}
>        ```
>
>        .csv {file.csv}
>        ~~~
>
>        1. Paragrafo
>        2. Citazione
>        3. Blocco di codice
>        4. Chiamata a funzione
>
>    .column
>        #### Inline
>
>
>        ```markdown
>        Lorem **ipsum**: ![Image](img.png)
>        ```
>
>        1. Testo `Lorem `
>        2. Grassetto `ipsum`
>        3. Testo `: `
>        4. Immagine `![Image](img.png)`


# Parsing

Viene generato l'albero del documento, in cui ogni token estratto dal lexer corrisponde ad un **nodo**.  
Vengono inoltre processati gli elementi innestati.

> `Paragraph(Un **paragrafo** con del testo. ![Immagine](img.url))`  
> !(_x250)[Nodo](img/uml/parsing-result.svg)

<<<

.row gap:{3cm}
    **Il parsing avviene ricorsivamente.**  
    Per ogni blocco viene rieseguito il processo di lexing e parsing.

    !(_x550)[Recursione](img/recursion.svg)

# Espansione delle chiamate

I nodi di tipo `FunctionCall` vengono letti da una coda e per ognuno:
1. Si risale alla funzione a cui fa riferimento in una delle librerie caricate
2. Viene controllata la validità della funzione
3. Viene ottenuto l'oggetto output della chiamata
4. L'output viene convertito in un elemento visibile sul documento

.row alignment:{spaceevenly}
    .fragment
        ```text
        .grid columns:{2} gap:{1cm}
            **Primo** elemento
            
            **Secondo** elemento
            
            **Terzo** elemento

            **Quarto** elemento
        ```

        .grid columns:{2} gap:{1cm}
            **Primo** elemento
            
            **Secondo** elemento
            
            **Terzo** elemento
            
            **Quarto** elemento
    
    .fragment
        ```text
        .var {radius} {8}
         
        L'area di un cerchio di **raggio .radius**
        è **.multiply {.pow {.radius} to:{2}} by:{.pi}**
        ```
    
        L'area di un cerchio di **raggio 8** è **201.06194**.

# Rendering

L'albero dei nodi viene percorso dalla radice, traducendo ogni nodo in un output per il linguaggio target.

> !(_x170)[Nodo](img/uml/parsing-result.svg)
> ```html
> <p>
>   Un <strong>paragrafo</strong> con del testo. <img src="img.url" alt="Immagine" />
> </p>
> ```

Nello stadio di **post-rendering** il codice prodotto viene iniettato in un template che adatta il contenuto a presentazioni, libri e articoli.

# Demo

&nbsp;

.fragment
    .text size:{medium}
        **Questa presentazione!**

    I sorgenti di questo documento sono disponibili su https://github.com/iamgio/quarkdown/tree/uni-thesis-presentation/presentation

<<<

.box {Temi}
    .grid columns:{2} gap:{5mm}
        !(_x200)[Darko](img/themes/darko.png "Darko + Minimal")
        !(_x200)[Latex](img/themes/latex.png "Paperwhite + Latex")
        !(_x200)[Beamer](img/themes/beamer.png "Beaver + Beamer")
        !(_x200)[Darkolatex](img/themes/darkolatex.png "Darko + Latex")
    